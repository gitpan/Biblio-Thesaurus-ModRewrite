%{
=head1 NAME

Biblio::Thesaurus::ModRewrite::Parser - The great new ...

=head1 VERSION

Version 0.01

=cut

our $VERSION = '0.01';

my $File;
my $t;

=head1 FUNCTIONS

=cut

=head2 new

TODO

=cut
%}

%%

program : statement_list { +{ program=>$_[1] } }
        ;

statement_list : statement_list statement DOT
           {
             my $n = keys %{$_[1]};
             +{ %{$_[1]}, $n=>$_[2]}
           }
           | { +{} }
           ;

statement : cond_block ARROW action_block { +{cond=>$_[1],action=>$_[3]} }
          | DO ARROW action_block { +{cond=>'true',action=>$_[3]} }
          ;

cond_block : token
           | token oper cond_block { +{$_[2] => [$_[1],$_[3]]} }
           ;

token: term relation term { [ $_[1], $_[2], $_[3] ]  }
     | TERM OPEN term CLOSE { $_[3] }
     | REL OPEN relation CLOSE { $_[3] }
     ;

term : STRING { +{'term'=>$_[1]} }
     | VAR { +{'var'=>$_[1]} }
     ;

relation : STRING { +{'relation'=>$_[1]} }
         | VAR { +{'var',$_[1]} }
         ;

oper : AND { 'and' }
     | OR { 'or' }
     ;

action_block : action_list
             ;

action_list : action_list action
               {
                 my $n = keys %{$_[1]};
                 +{ %{$_[1]}, $n=>$_[2] }
               }
            | { +{} }
            ;

action : ACTION OPEN token CLOSE { +{ $_[1] => $_[3] } }
       | SUB CODE { +{ $_[1] => $_[2] } }
       ;

%%

=head2 lex

TODO

=cut

sub lex {
    for ($File) {
        s!^\s+!!;
        ($_ eq '')    and return ('',undef);

        s!^(\=\>)!!    and return('ARROW',$1);
        s!^(and|\&\&)!!i    and return('AND',$1);
        s!^(or|\|\|)!!i    and return('OR',$1);
        s!^(not|\!)!!i    and return('NOT',$1);
        s!^(do|begin|end)!!i    and return('DO',$1);
        s!^(\=\>)!!    and return('ARROW',$1);
        s!^(\:)!!    and return('COLON',$1);
        s!^(\()!!    and return('OPEN',$1);
        s!^(\))!!    and return('CLOSE',$1);
        s!^(\,)!!    and return('COMMA',$1);
        s!^(\.)!!    and return('DOT',$1);
        s!^(sub)!!    and return('SUB',$1);
        #s!^\{(.*)\}!!s    and print "|$1|\n" and return('CODE',$1);
        s!^\{([^{}]*(\{[^{}]*\}[^{}]*)*)\}!!s and return('CODE',$1);

        s!^(term)!!    and return('TERM',$1);
        s!^(rel)!!    and return('REL',$1);
        s!^(add|delete)!!    and return('ACTION',$1);
        if (s!^(\w+|\'.*?\'|\".*?\")!!) {
            my $zbr = $1;
            $zbr =~ s/\'|\"//g;
            return('STRING',$zbr);
        }
        s!^\$([a-z]+)!!    and return('VAR',$1);
    }
}

=head2 yyerror

TODO

=cut

sub yyerror {
  if ($_[0]->YYCurtok) {
      printf STDERR ('Error: a "%s" (%s) was found where %s was expected'."\n",
         $_[0]->YYCurtok, $_[0]->YYCurval, $_[0]->YYExpect)
  }
  else { print  STDERR "Expecting one of ",join(", ",$_[0]->YYExpect),"\n";
  }
}

=head2 init_lex

TODO

=cut

sub init_lex {
    my $self = shift;
    $File = shift;

    local $/;
    undef $/;
    #$File = <>
}

# vim: set filetype=perl
